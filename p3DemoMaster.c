#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     p3DemoMaster.c                                               */
/*    Author:     James Pearman                                                */
/*    Created:    13 August 2013                                               */
/*                                                                             */
/*    Revisions:                                                               */
/*                V1.00  13 Aug 2013 - Initial release                         */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program , however, it is requested that    */
/*    improvements or additions be shared with the Vex community via the vex   */
/*    forum.  Please acknowledge the work of the authors when appropriate.     */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the vex forums as jpearman                */
/*    or electronic mail using jbpearman_at_mac_dot_com                        */
/*    Mentor for team 8888 RoboLancers, Pasadena CA.                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Description:                                                             */
/*    Communications Demo code for cortex acting as master                     */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#include "p3comms.c"

/*---------------------------------------------------------------------------*/
/*  define application specific commands                                     */
/*---------------------------------------------------------------------------*/

#define CMD2_CONTROL_SETMOTORS          0x10
#define CMD2_CONTROL_SET_MOTOR_BY_INDEX 0x11

#define CMD2_STATUS_GETMOTORS           0x10

// The init here does not work in ROBOTC so needs to be done later
static  p3cmd   Cmd_Set_Motors          = { CMD1_GROUP_CONTROL, CMD2_CONTROL_SETMOTORS,         10 };
static  p3cmd   Cmd_Set_Motor_ByIndex   = { CMD1_GROUP_CONTROL, CMD2_CONTROL_SET_MOTOR_BY_INDEX, 2 };
static  p3cmd   Cmd_Motor_Status_Req    = { CMD1_GROUP_STATUS,  CMD2_STATUS_GETMOTORS,           0 };

// storage for the motor date we send to the slave
static  short   remote_motor[ 10 ];

/*---------------------------------------------------------------------------*/
/*  Example status reply decode                                              */
/*---------------------------------------------------------------------------*/

int
P3UserDecodeStatusReply( p3comms *MyComms, p3pak *packet )
{
    p3cmdfull   *cmd = &packet->command.cmdpak.cmd;
    int          ret = 1;

    switch( cmd->cmd2 )
        {
        // Get all motors
        case    CMD2_STATUS_GETMOTORS:
            // Check for valid data length
            if( cmd->length == 10 ) {
                // data is in range 0-254, shift to +/- 127
                remote_motor[port1]  = cmd->data[0] - 0x7F;
                remote_motor[port2]  = cmd->data[1] - 0x7F;
                remote_motor[port3]  = cmd->data[2] - 0x7F;
                remote_motor[port4]  = cmd->data[3] - 0x7F;
                remote_motor[port5]  = cmd->data[4] - 0x7F;
                remote_motor[port6]  = cmd->data[5] - 0x7F;
                remote_motor[port7]  = cmd->data[6] - 0x7F;
                remote_motor[port8]  = cmd->data[7] - 0x7F;
                remote_motor[port9]  = cmd->data[8] - 0x7F;
                remote_motor[port10] = cmd->data[9] - 0x7F;
                }
            break;

        default:
            ret = 0;
            break;
        }

    return(ret);
}

/*---------------------------------------------------------------------------*/
/*      Decode a received packet and take appropriate action                 */
/*---------------------------------------------------------------------------*/

int
P3UserDecodePacket( p3comms *MyComms, p3pak *packet )
{
    int     ret = 1;

    // detect command group
    switch( packet->masked_cmd1 )
        {
        case    CMD1_GROUP_STATUS_REPLY:
            ret = P3UserDecodeStatusReply( MyComms, packet );
		    break;

        default:
            ret = 0;
            break;
        }

    return(ret);
}

/*-----------------------------------------------------------------------------*/
/*  serial comms task                                                          */
/*-----------------------------------------------------------------------------*/

p3comms  *MyComms;

task serialCommsTask()
{
    // bump our priority
    setTaskPriority(serialCommsTask, 20);

    // check for messages
    while( true )
        {
        // run communications
        if(MyComms != NULL)
            P3CommsTask( MyComms );

        // P3 comms task expects to be run every 2mS
        wait1Msec(2);
        }
}

/*-----------------------------------------------------------------------------*/
/*  Task that sends messages to the slave                                      */
/*-----------------------------------------------------------------------------*/

typedef enum {
    kStateIdle        =  0,
    kStateCheckOnline = 10,
    kStateCheckInit_1 = 20,
    kStateCheckInit_2,
    kStateCheckInit_3,
    kStateCheckInit_4,
    kStateCheckInit_5,
    kStateCheckInit_6,
    kStatePoll        = 30
    } commsState;

task serialMasterTask()
{
    static  commsState  state;
            int     i;

    // Init user commands - :( no struct init in ROBOTC
    RobotC_InitCmd( &Cmd_Set_Motors,        CMD1_GROUP_CONTROL, CMD2_CONTROL_SETMOTORS,         10 );
    RobotC_InitCmd( &Cmd_Set_Motor_ByIndex, CMD1_GROUP_CONTROL, CMD2_CONTROL_SET_MOTOR_BY_INDEX, 2 );
    RobotC_InitCmd( &Cmd_Motor_Status_Req,  CMD1_GROUP_STATUS,  CMD2_STATUS_GETMOTORS,           0 );

    while(1)
        {
        if( state >= kStateCheckInit_1 )
            {
            if( MyComms->online == 0 )
                 state = kStateIdle;
            }

        switch(state)
            {
            case    kStateIdle:
                // Use device ID as the message to detect slave presence
                P3Command( MyComms, &Cmd_Dev_Type, CORTEX_DEVICE_ID  );
                state++;
                break;

            case    kStateCheckOnline:
                if( MyComms->online != 0 )
                    state = kStateCheckInit_1; // reply received so move on
                else
                    state = kStateIdle;        // Try again
                break;

            // Ask for all system related stuff just for fun.
            case    kStateCheckInit_1:
                P3Command( MyComms, &Cmd_Manufacturer_Request, CORTEX_DEVICE_ID  );
                state++;
                break;
            case    kStateCheckInit_2:
                P3Command( MyComms, &Cmd_ProductName_Request, CORTEX_DEVICE_ID  );
                state++;
                break;
            case    kStateCheckInit_3:
                P3Command( MyComms, &Cmd_SerialNumber_Request, CORTEX_DEVICE_ID  );
                state++;
                break;
            case    kStateCheckInit_4:
                P3Command( MyComms, &Cmd_FirmwareRev_Request, CORTEX_DEVICE_ID  );
                state++;
                break;
            case    kStateCheckInit_5:
                P3Command( MyComms, &Cmd_HardwareRev_Request, CORTEX_DEVICE_ID  );
                state++;
                break;

            case    kStateCheckInit_6:
                // Get current status of remote motors
                // we don't do much with this other than save when the reply arrives
                // if motors not under js control were running they will maintain
                // their current speed.
                P3Command( MyComms, &Cmd_Motor_Status_Req, CORTEX_DEVICE_ID  );
                state =     kStatePoll;
                break;

            case        kStatePoll:
                // for demo, move joystick data into motors 0 through 3
                remote_motor[0] = vexRT[ Ch1 ];
                remote_motor[1] = vexRT[ Ch2 ];
                remote_motor[2] = vexRT[ Ch3 ];
                remote_motor[3] = vexRT[ Ch4 ];

                // Send data for all motors
                for( i=0;i<9;i++ )
                    Cmd_Set_Motors.data[i] = remote_motor[i] + 0x7F;

                P3Command( MyComms, &Cmd_Set_Motors, CORTEX_DEVICE_ID  );
                break;

            default:
                state++;
                break;
            }

        // debug - show online/offline on LCD
        if( MyComms->online == 0 )
            displayLCDString(1, 0, "Offline");
        else
            displayLCDString(1, 0, "Online ");

        wait1Msec(10);
        }
}

task main()
{
    // Open comms in master mode
    MyComms = P3Init( UART1, kP3ModeMaster, 0, baudRate230400 );

    // Start task if no error
    if(MyComms != NULL)
        {
        StartTask(serialCommsTask);
        StartTask(serialMasterTask);
        }

    bLCDBacklight = true;

    // nothing to do here, all done by other tasks
    while(1)
        {
        wait1Msec(100);
        }
}
