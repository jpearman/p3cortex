#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(Sensor, dgtl1,  ,               sensorLEDtoVCC)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Module:     p3DemoSlave.c                                                */
/*    Author:     James Pearman                                                */
/*    Created:    13 August 2013                                               */
/*                                                                             */
/*    Revisions:                                                               */
/*                V1.00  13 Aug 2013 - Initial release                         */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    The author is supplying this software for use with the VEX cortex        */
/*    control system. This file can be freely distributed and teams are        */
/*    authorized to freely use this program , however, it is requested that    */
/*    improvements or additions be shared with the Vex community via the vex   */
/*    forum.  Please acknowledge the work of the authors when appropriate.     */
/*    Thanks.                                                                  */
/*                                                                             */
/*    Licensed under the Apache License, Version 2.0 (the "License");          */
/*    you may not use this file except in compliance with the License.         */
/*    You may obtain a copy of the License at                                  */
/*                                                                             */
/*      http://www.apache.org/licenses/LICENSE-2.0                             */
/*                                                                             */
/*    Unless required by applicable law or agreed to in writing, software      */
/*    distributed under the License is distributed on an "AS IS" BASIS,        */
/*    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. */
/*    See the License for the specific language governing permissions and      */
/*    limitations under the License.                                           */
/*                                                                             */
/*    The author can be contacted on the vex forums as jpearman                */
/*    or electronic mail using jbpearman_at_mac_dot_com                        */
/*    Mentor for team 8888 RoboLancers, Pasadena CA.                           */
/*                                                                             */
/*-----------------------------------------------------------------------------*/
/*                                                                             */
/*    Description:                                                             */
/*    Communications Demo code for cortex acting as slave                      */
/*                                                                             */
/*-----------------------------------------------------------------------------*/

#include "p3comms.c"

/*---------------------------------------------------------------------------*/
/*  define application specific commands                                     */
/*---------------------------------------------------------------------------*/

#define CMD2_CONTROL_SETMOTORS          0x10
#define CMD2_CONTROL_SET_MOTOR_BY_INDEX 0x11

#define CMD2_STATUS_GETMOTORS           0x10

// The init here does not work in ROBOTC so needs to be done later
static  p3cmd   Cmd_Motor_Status    = { CMD1_GROUP_STATUS_REPLY, CMD2_STATUS_GETMOTORS, 0 };

/*---------------------------------------------------------------------------*/
/*  Example control commands                                                 */
/*---------------------------------------------------------------------------*/

int
P3UserDecodeControl( p3comms *MyComms, p3pak *packet )
{
    p3cmdfull   *cmd = &packet->command.cmdpak.cmd;
    int          ret = 1;
    int          index;

    switch( cmd->cmd2 )
        {
        // Set all motors
        case   CMD2_CONTROL_SETMOTORS:
            // Check for valid data length
            if( cmd->length == 10 ) {
                // data is in range 0-254, shift to +/- 127
                motor[port1]  = cmd->data[0] - 0x7F;
                motor[port2]  = cmd->data[1] - 0x7F;
                motor[port3]  = cmd->data[2] - 0x7F;
                motor[port4]  = cmd->data[3] - 0x7F;
                motor[port5]  = cmd->data[4] - 0x7F;
                motor[port6]  = cmd->data[5] - 0x7F;
                motor[port7]  = cmd->data[6] - 0x7F;
                motor[port8]  = cmd->data[7] - 0x7F;
                motor[port9]  = cmd->data[8] - 0x7F;
                motor[port10] = cmd->data[9] - 0x7F;

                // Send ACK
                P3Command(MyComms, &Cmd_Ack, packet->dev_id  );
                }
            else
                // Send NAK
                P3Command(MyComms, &Cmd_Nak_Para_Err, packet->dev_id  );
            break;

        // Set motor by index
        case   CMD2_CONTROL_SET_MOTOR_BY_INDEX:
            // Check for valid data length
            if( cmd->length == 2) {
                // first data byte is motor index in range 0 to 9
                index = cmd->data[0];
                // bounds check the index
                if( (index >= 0) && (index<=9) ) {
                    // data is in range 0-254, shift to +/- 127
                    motor[index] = cmd->data[1] - 0x7F;

                    // Send ACK
                    P3Command(MyComms, &Cmd_Ack, packet->dev_id  );
                    }
                else
                    P3Command(MyComms, &Cmd_Nak_Para_Err, packet->dev_id  );
                }
            else
                P3Command(MyComms, &Cmd_Nak_Para_Err, packet->dev_id  );
            break;

        default:
            ret = 0;
            break;
        }

    return(ret);
}

/*---------------------------------------------------------------------------*/
/*  Example status request and reply                                         */
/*---------------------------------------------------------------------------*/

int
P3UserDecodeStatus( p3comms *MyComms, p3pak *packet )
{
    p3cmdfull   *cmd = &packet->command.cmdpak.cmd;
    int          ret = 1;

    switch( cmd->cmd2 )
        {
        // Get all motors
        case    CMD2_STATUS_GETMOTORS:
            // shift +- 127 to 0-254 range
            Cmd_Motor_Status.data[0] = motor[port1] + 0x7F;
            Cmd_Motor_Status.data[1] = motor[port2] + 0x7F;
            Cmd_Motor_Status.data[2] = motor[port3] + 0x7F;
            Cmd_Motor_Status.data[3] = motor[port4] + 0x7F;
            Cmd_Motor_Status.data[4] = motor[port5] + 0x7F;
            Cmd_Motor_Status.data[5] = motor[port6] + 0x7F;
            Cmd_Motor_Status.data[6] = motor[port7] + 0x7F;
            Cmd_Motor_Status.data[7] = motor[port8] + 0x7F;
            Cmd_Motor_Status.data[8] = motor[port9] + 0x7F;
            Cmd_Motor_Status.data[9] = motor[port10] + 0x7F;
            // reply with motor status
            P3Command(MyComms, &Cmd_Motor_Status, packet->dev_id  );
            break;

        default:
            ret = 0;
            break;
        }

    return(ret);
}

/*---------------------------------------------------------------------------*/
/*      Decode a received packet and take appropriate action                 */
/*---------------------------------------------------------------------------*/

int
P3UserDecodePacket( p3comms *MyComms, p3pak *packet )
{
    int     ret = 1;
    static  long msgCount = 0;
    string  str;

    // detect command group
    switch( packet->masked_cmd1 )
        {
		case    CMD1_GROUP_CONTROL:
    		ret = P3UserDecodeControl( MyComms, packet );
		    break;

        case    CMD1_GROUP_STATUS:
            ret = P3UserDecodeStatus( MyComms, packet );
		    break;

        default:
            ret = 0;
            break;
        }

    // Some debug - show message received and flash LED
    if(ret == 1)
        {
        msgCount++;
        SensorValue[dgtl1] = (msgCount >> 5) & 1;
        sprintf(str,"%08d", msgCount);
        displayLCDString(1, 0, str);
        }

    return(ret);
}

/*-----------------------------------------------------------------------------*/
/*  serial comms task                                                          */
/*-----------------------------------------------------------------------------*/

task serialCommsTask()
{
    p3comms  *MyComms;

    // bump our priority
    setTaskPriority(serialCommsTask, 20);

    // Open comms in slave mode
    MyComms = P3Init( UART1, kP3ModeSlave, 0, baudRate230400 );

    // Error - then quit
    if(MyComms == NULL)
        return;

    // set device type - whatever you want
	MyComms->deviceType[0] = 0x12;
	MyComms->deviceType[1] = 0x34;

	// Set various system message details
	P3SetManufacturerString( MyComms, "VEX");
    P3SetProductNameString( MyComms, "CORTEX");
    P3SetSerialNumberString( MyComms, "00001" );
    P3SetFirmwareVersion( MyComms, 1, 0, 0, 0);
    P3SetHardwareVersion( MyComms, 1, 0, 0 );

    // Init user commands - :( no struct init in ROBOTC
    RobotC_InitCmd( &Cmd_Motor_Status, CMD1_GROUP_STATUS_REPLY, CMD2_STATUS_GETMOTORS, 10 );

    // check for messages
    while( true )
        {
        // run communications
        if(MyComms != NULL)
            P3CommsTask( MyComms );

        // P3 comms task expects to be run every 2mS
        wait1Msec(2);
        }
}

task main()
{
    StartTask(serialCommsTask);

    bLCDBacklight = true;

    // nothing to do here, all done by comms task
    while(1)
        {
        wait1Msec(100);
        }
}
